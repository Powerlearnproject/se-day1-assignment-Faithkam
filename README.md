[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15575673&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the application of engineering principles, methods, tools for the development and maintenance of high-quality software systems. The processes involved include product software design, development/implementation, testing, deployment as well as maintenance of software products. It plays a crucial role in the technology industry by creating software systems and applications that impact various aspects of modern life such as communication, e-commerce, entertainment, healthcare. Moreover, software solutions created are reliable, scalable and innovative to meet user needs. 

Identify and describe at least three key milestones in the evolution of software engineering.
Three key milestones in the evolution of software engineering include, the development of programming languages, the establishment of software engineering as a discipline in the 1960s, the rise of agile methodologies in the 2000s.

The development of programming languages played a vital role in the evolution of software engineering.  Examples of programming languages that emerged include Fortran, C, Python. Fortran in short for Formula translation was established in the 1950s by IBM for scientific and engineering calculations. Unlike assembly languages, Fortran introduced various important concepts ranging from variables, control structures and input/output operations in a more friendly format. C was developed by Dennis Ritchie in the 1970s to account for shortfalls in programming languages such as Fortran and assembly languages in terms of system programming and portability. C incorporated key concepts such as structured programming, pointers and modularity. Its influence is seen in languages such as C++, objective-C, and its methods continue to underpin various modern programming languages

The establishment of software engineering as a discipline in the 1960s
Programming languages such as Fortran, which enabled developers to apply mathematical and scientific computations led to the growth of software engineering as a discipline. Prior to the establishment of software engineering as a discipline, software development was reliant upon an unstructured code that was difficult to manage and maintain. The programming practices were characterized by complicated control flows. The introduction of structured programming characterized by loops and conditionals rather than GOTO statements led to clear, logical control structures and modular designs which improved code readability and, maintainability. Structured programming model led to the evolution of software engineering practices by using better code organization and reducing the complexity of software systems.

The rise of agile methodologies in the 2000s
The use of traditional methodologies in software development, like the waterfall had its drawbacks in that it failed to adapt to changes and the evolving requirements of software development. This led to the evolution of more flexible and iterative approaches. Inorder to formalize the principles of Agile software development, the Agile Manifesto was established in 2001, with methodologies such as Scrum, Extreme programming. These approaches focussed on iterative development, collaboration and feedback, which enabled the delivery of incremental improvements and responsiveness to changes more effectively. These methodologies have influenced how software is developed, managed and delivered across various domains


List and briefly explain the phases of the Software Development Life Cycle.
The Software Development life cycle (SDLC) consists of many phases including 
•	Requirements: this phase involves gathering and jotting down information about user needs and the systems requirement.
•	Design: involves the creation of high-level and detailed designs of the software architecture as well as user interface
•	Implementation: the process involves writing code and building the software according to the design specifications.
•	Testing: this phase involves running various tests to ensure that the software adheres to the quality standards and the functional requirements
•	Deployment: at this stage, the software is released to users
•	Maintenance: involves providing ongoing support, updates and enhancements to the software after deployment
Each stage is crucial for delivering high-quality software products that meet the users needs and maintain compatibility with evolving technology platforms.


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
There are various development methodologies that guide the software development process, each depending upon the requirements of the projects, the level of involvement of the user/client and the degree of uncertainty in the process. A comparison of the two methods will be based on approach to development, requirements management, planning of the project and execution, testing, customer involvement, flexibility and adaptability

Approach to development
The waterfall methodology is based on a sequential approach, whereby each phase must be completed prior to starting a new one. It is predictive in that it requires all the requirements to be gathered prior to the commencement of the project, and that changes are costly and disruptive. This approach is best suited for projects with clearly defined requirements and minimal changes are expected. The agile methodology follows an iterative approach, whereby development inform of iterations is done producing a working piece of software, requirements are altered based on feedback from previous iterations. Required changes can be incorporated regardless of the stage in the development process, enabling flexibility and responsiveness to the needs of the user. The agile approach is ideal for projects with ever-changing requirements, which needs regular adjustments. It is based on delivering small, incremental improvements.

Requirements management
The waterfall methodology requires extensive documentation at the beginning of the project, assumes that changes to requirements can lead to extensive costs and delays. The Agile approach requires less documentation and is sorely based on teamwork fostering close relationships with stakeholders to adapt to new information and feedback.

Project planning and execution
Interms of project planning, the waterfall requires a detailed project plan prior to development, which outlines the scope, timelines and resources. The methodology has longer development cycles compared to the Agile approach, whereby testing is executed only after the development phase is completed. The Agile methodology involves continuous planning, with regular review checks and adjustment planning. Due to shorter timelines, working softwares are released quickly.

Testing 
Testing is done once the development phase is completed in the Waterfall methodology, whereas the agile approach allows for continuous testing throughout the process. The Agile approach incorporates testing in every iteration to ensure that features added work correctly and do not introduce new issues whereas the waterfall approach is based on the ideology that new issues detected on the testing phase can be costly and may result in resorting back to earlier phases.

Flexibility and adaptability
The waterfall approach is less flexible, changes to requirements are difficult to implement once the project is underway. This approach is less suitable to dynamic and complex projects, where requirements are not clear from the beginning. The agile methodology is highly flexible, incorporating changes and adapting to ever-changing requirements. It is ideal for projects with dynamic requirements.

Customer involvement
Customer involvement is limited when it comes to the Waterfall approach and is often evident in the requirement phase. Late feedback from customers is a challenge once the projects is in later stages, whereas the agile approach enables frequent feedback from customers at the end of each sprint, allowing for adjustments and refinements. 


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
Software developer
The roles and responsibilities of a software developer vary depending on the type of projects, the size of an organization and the methodologies applicable. Software developers liaise with stakeholder to understand and document software requirements. They are responsible for writing code and implementing software solutions according to the design specification and coding standards. Moreover, they assess the viability of the proposed solutions in terms of time, technology and resources. In addition, they develop comprehensive design specifications, including algorithms, user interface and data structures. Software developers may also take specialized roles based on their expertise and requirements of the projects ranging from front-end, back-end, full stack, mobile developer.

Quality Assurance Engineer
Ensures quality of software by designing and executing test plans which includes the type of tests to be done, tools to be employed and the test environment setup. The QA engineer ensures that requirements are clearly defined, complete and testable through effective collaborations with stakeholders, to understand and clarify requirements and acceptance criteria. Moreover, they are responsible for verifying that the software meets both functional and non-functional requirements, not subject to critical defects, and is user-friendly.

Project manager
A project manager (PM) is responsible for managing various aspects of the project, ensuring successful delivery within the constraints of scope, time , and budget. They oversee the planning, execution and delivery of software projects, liaise with stakeholders, providing feedback regarding project status, issues and changes. The PM is responsible for managing stakeholders’ expectations by setting achievable goals and addressing concerns on a timely basis. Moreover, they assemble teams and assign tasks and duties based on team member’s skills and the requirements of the project. Project managers identify risks and issues that could affect the project and design mitigation strategies to address the identified risks and lessen their impact. They also monitor and control project expenses to ensure that they align with the budget.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
Integrated Development Environments (IDEs)
These are crucial tools in software development, which provide detailed tools for writing, debugging and testing code. IDEs intergrate various development tools into a unified interface, thus minimizing the need to switch between different applications and improving the overall workflow efficiency. Moreover, IDEs enhances productivity, in that they offer code completions and suggestions which assist in fast-tracking coding by minimizing the amount of manual typing and syntax errors. IDEs have powerful debugging and troubleshooting tools, which allows developers to perform tasks such as setting breakpoints, inspecting variables, analyzing call stacks within the same space where they write their code. IDEs enhances team collaboration by incorporating features such as shared coding sessions, collaborative debugging, live code sharing, which facilitates shared problem solving. In addition, IDEs enhances learning and support by offering extensive documentation, forums and tutorials to large user communities. Examples include Visual Studio, Eclipse, Intellij IDEA.

Version Control Systems (VCS)
These are software tools for tracking modifications to source code and coordinating work among team members, which enhances the overall development workflow. Version control systems store historical information about changes made to the codebase, which is vital for understanding the evolution of a project. Moreover, it enables developers to revert to previous versions of the code to restore functionality if a bug is detected due to recent changes. VCS allows developers to create branches to work on new features and conduct experiments without affecting the main codebase. Branches can be merged into the main branch once work is completed. VCS improves code quality and review in that it enables developers to discuss changes prior to merging, which assist in detecting issues early and improving the overall code quality. In addition, VCS maintain documentation and knowledge, which enables new team members to understand the motive behind changes and the evolution of the codebase. VCS also serves as backup mechanisms, in the event of accidental deletions or corruptions, previous versions of the files can be restored. VCS also facilitate experimentation and innovation in the sense that developers are free to test new features on branches created without risking the stability of the main codebase. Moreover, they reduce misunderstandings and conflicts through effective communication and collaborations by team members. Examples of VCS include Git and Subversion. Git is mainly used for source code management and tools such as Github, Gitlab, Bitbucket provide collaboration features, repositories, and CI/CD integration. Subversion is another option for version control, although it is less popular.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Software engineers encounter many challenges in the development process ranging from tight deadlines, changing requirements, technical debt, team collaboration and communication.
Ever-changing requirements from stakeholders at any stage of the project may affect timelines, budgets and overall stability of the project. Unclearly defined requirements can result in misaligned expectations, delays and misunderstandings. This can be minimized through regular reassessment of project goals and requirements as well as timelines. Moreover, the Agile methodology is ideal for projects with evolving requirements. 

Technical debt can accrue from accumulated shortcuts and suboptimal solutions to meet deadlines, thus compromising on the overall quality of the project, increase maintenance costs and impede future development efforts. This challenge can be minimized by scheduling regular refactoring sessions to address technical debt and improve code quality. Moreover, use automated tools to detect and fix issues as they arise.

Communication challenges, difficulties in aligning work, managing conflicts and differences in opinion may arise among team members who are geographically dispersed. Challenges in balancing project deadlines without compromising on quality may arise leading to pressure and stress. This can be addressed through effective prioritization of tasks and time management to focus on critical issues as they arise.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit testing
This type of testing involves testing individual components or modules of software in isolation to ensure they function correctly. It focusses on functions and methods ( the smallest testable parts of an application). Unit testing is crucial in that it enables early detection of bugs by testing components in isolation. More so, it fosters better structures and more reliable quality code. Unit testing simplifies the debugging process by making it relatively easier to track the exact location of the problem, should unit test fail, which makes the process efficient. In addition, unit tests facilitate the documentation process by providing information regarding how each unit of the code is supposed to work as well as providing examples of its usage, which can assist new members joining the project.

Integration testing
The purpose of integration testing is to test the interaction between different integrated components or systems to ensure that they work together as expected. Its focus is on interfaces and data flow between modules and services. Integration testing encourages effective collaboration and communication between team members responsible for different components, making sure that everyone’s work aligns with the overall requirements of the system. Moreover, it ensures that workflows and business processes that involve multiple components work as expected, thereby validating end-to-end functionality. Integrating testing helps to detect interface issues such as data format mismatches, incorrect data handling, or communication errors particularly in instances where components are developed by different teams. It reduces risk of regression that may arise due to changes in one part of the system affecting the other parts.

System testing
It involves testing the entire system as a whole to verify that it meets the specified requirements. Testing includes interaction between components and subsystems. This testing phase is important in that it checks that the system meets all specified requirements, including functional and non-functional requirements such as usability, performance and security. Systems testing helps to identify issues that may occur when components work together in a full system context, its checks are not limited to interactions with external systems and services , but the entire system’s integration. Moreover, systems testing evaluates the software from the perspective of the end-user, ensuring that all requirements, including user interface, usability and overall user experience meet the expectations of the user. Systems testing involves performance testing which assist in detecting issues pertaining to system performance such as slow response times or high resource consumption.

Acceptance testing
Involves testing against user requirements to ensure that it meets the needs of the user. The test is usually conducted by the end user or Quality Assurance team to verify if the software meets the user needs and requirements. This testing is crucial in that it ensures that the quality aspect of the software is not compromised and that it is free from defects that could affect its functionality. In addition, it confirms compliance with requirements, by ensuring that the software adheres to the required standards and regulations. This fulfills the legal and contractual obligations. Acceptance testing facilitate stakeholder approval in that, successful completion of testing is dependent upon stakeholder approval and satisfaction before project sign-off.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is about crafting questions and statements to get the optimal responses from AI models. It helps to avoid confusing results from vague questions by ensuring that questions posed are clear and specific, enabling AI to understand exactly wat is needed. Well-crafted questions enhances the accuracy of AI model responses, thus generating relevant and more precise outputs. Effective prompt engineering assist end-users in formulating questions that the model can understand, thus improving the overall experience of the end-user. Prompt engineering facilitates better interaction in conversational AI and virtual assistants by formulating engagements and interactions that bring about meaningful and contextual responses, enhancing quality interaction. In addition, it is vital for preparing AI models to different use cases, such as customer support, content generation and data analysis.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
An example of a vague prompt is as follows
‘Give me information on health’

This prompt is broad and lacks specificity, making AI to deliver a general answer. The prompt does not provide clarity on the subject matter, resulting in a broad range of possible answers that may not match what the end user might want to know. An improved prompt is as follows.

‘can you provide a brief review of the benefits of a well balanced diet for improving cardiovascular health’
This prompt is concise and specific in the sense that it narrows down a broader topic of ‘health’ to ‘benefits of a well-balanced diet’. Moreover, it is clear and direct in that it mentions ‘cardiovascular health’, which enables AI to provide essential information about how diet affects heart health. The prompt has a defined output ‘review’, indicating the desired format of the answer.


